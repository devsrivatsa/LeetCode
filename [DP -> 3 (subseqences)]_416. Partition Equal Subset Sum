
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        if len(nums) == 1: #if there is only 1 item in the list, then False
            return False
        if sum(nums)%2 != 0: #if there are odd numner of items in list, then False
            return False
        target = sum(nums)//2
        
        #memoization is always in terms of index and target of the problem. Here the target is equal sum in both sub arrays
        #(idx, target) = in this entire array till index=idx, does there exist a number=target

        def memoization(idx,target,dp):
            if target==0:#if there is nothing more to do, return true as the goal has been achieved
                return True
            if idx==0:# if we are at the first index starting from the last, then either the element is what we are looking for, or it isn't
                return nums[idx]==target
            if dp[idx][target] != -1:
                return dp[idx][target]
            dont_take = memoization(idx-1, target, dp) #target remains the same if we do not choose the item
            take=False
            if target >= nums[idx]:
                take = memoization(idx-1, target-nums[idx], dp) #target decreases if we choose the item
            #take has a possibility of containing the target
            #dont_take has a possibility of containing the target
            #we want to know if there is a possibility either way
            dp[idx][target] = take or dont_take
            return dp[idx][target]
        
        def tabulation():
            for idx in range(1, len(nums)):
                for t in range(1, target+1):
                    dont_take = dp_tab[idx-1][t]
                    take=False
                    if t >= nums[idx]:
                        take = dp_tab[idx-1][t-nums[idx]]
                    #print((idx, t), take, dont_take)
                    dp_tab[idx][t] = take or dont_take
            return dp_tab[len(nums)-1][target]

        ###The dp array: dp=[idx][target] a 2d array
        
        ###dp for memoization
        # dp_memo = [[-1]*(target+1) for _ in range(len(nums))] #the dp array is 2d: index, target
        # for i in range(len(nums)):
        #     dp_memo[i][0] = True
        # return memoization(len(nums)-1, target, dp_memo)
        
        ###dp for tabulation (tabulation cannot have integer dp array in this case)
        dp_tab = [[False]*(target+1) for _ in range(len(nums))] 
        for i in range(len(nums)):
            dp_tab[i][0] = True
        return tabulation()
